var documenterSearchIndex = {"docs":
[{"location":"temp/#State","page":"-","title":"State","text":"","category":"section"},{"location":"temp/#Schedule","page":"-","title":"Schedule","text":"","category":"section"},{"location":"temp/#Process","page":"-","title":"Process","text":"","category":"section"},{"location":"temp/","page":"-","title":"-","text":"We can increase the dimension of our state space. Consider for instance","category":"page"},{"location":"temp/","page":"-","title":"-","text":"state_4D = State((0.0,0.0,0.0,0.0))\nsample_4D = Sample(state_4D, schedule, process) ","category":"page"},{"location":"temp/","page":"-","title":"-","text":"which samples a realization of a 4D Brownian motion. As opposed to plotting coordinate value against time, we can plot any pair of coordinates against each other. For instance","category":"page"},{"location":"temp/","page":"-","title":"-","text":"plot(sample_4D,[1,4])","category":"page"},{"location":"temp/","page":"-","title":"-","text":"produces a two dimensional plot where first coordinates are mapped onto the x axis and the fourth coordinates are mapped onto the y axis.","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: 2D sample plot)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"We can specify schedule with increasing complexity. ","category":"page"},{"location":"temp/","page":"-","title":"-","text":"tree_schedule = InvariantStopping.Tree([0.0,1.0,2.0,3.0],3);\n\ntree_sample = Sample(state, tree_schedule, process);\nplot(tree_sample)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: 1D ternary tree plot)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"And in 4D","category":"page"},{"location":"temp/","page":"-","title":"-","text":"ternary_sample_4D = Sample(state_4D, tree_schedule, process);\nplot(ternary_sample_4D,[1,4]) # Plotting coordinate 1 against coordinate 4","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: 2D ternary tree plot)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"Schedule accepts LinRange as well. For instance","category":"page"},{"location":"temp/","page":"-","title":"-","text":"star_schedule = InvariantStopping(Star(LinRange(0,5,10),40));\nstar_sample = Sample(state, star_schedule, process);\nplot(star_sample)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: 1D star plot)","category":"page"},{"location":"temp/#Schedule-2","page":"-","title":"Schedule","text":"","category":"section"},{"location":"temp/","page":"-","title":"-","text":"Let's first take a look at the following","category":"page"},{"location":"temp/","page":"-","title":"-","text":"schedule = InvariantStopping.Tree([0,1,2],3)\nsample = Sample(state, schedule, process)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"This generates a tree of samples.","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: Ternary Tree)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"Note that the above tree can be interpreted as a tree of stopping times with deterministic stopping times.","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: Ternary Tree)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"These deterministic stopping times could be replaced by arbitary stopping times.","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: Ternary Tree)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"One can see that schedules can be made very general.","category":"page"},{"location":"temp/","page":"-","title":"-","text":"(Image: Ternary Tree)","category":"page"},{"location":"temp/","page":"-","title":"-","text":"To craft our own schedule, we must first define a stopping time and the stopping opportunities it contained.","category":"page"},{"location":"temp/#Stopping-Time-and-Stopping-Opportunity","page":"-","title":"Stopping Time and Stopping Opportunity","text":"","category":"section"},{"location":"temp/","page":"-","title":"-","text":"For instance","category":"page"},{"location":"temp/","page":"-","title":"-","text":"function predicate_1(x,y) \n  return x - 2.0*y > 1.0\nend\n\nfunction predicate_2(x,y)\n  return x + 1.0 > 0.5\nend\n\nstopping_time_1 = HittingTime(predicate_1, LinRange(0.0,10,20))\nstopping_time_2 = HittingTime(predicate_2, LinRange(0.0,10,20))\n\nschedule = Schedule(stopping_time_1, [Schedule(stopping_time_2)for _ in 1:10])\n\nsample = Sample(state,schedule, underlying_model)","category":"page"},{"location":"temp/#Process-2","page":"-","title":"Process","text":"","category":"section"},{"location":"dev/#Plumbing","page":"Dev","title":"Plumbing","text":"","category":"section"},{"location":"dev/","page":"Dev","title":"Dev","text":"We first go over a simple case where the need for a LoweredSchedule is apparent.","category":"page"},{"location":"dev/#Stopping-Opportunity","page":"Dev","title":"Stopping Opportunity","text":"","category":"section"},{"location":"dev/","page":"Dev","title":"Dev","text":"First we recall that a stopping opportunity is a unit of decision. It is specified by a predicate and a list of timestamps. The predicate is simply a function that takes a collection of states and returns true or false. The states are sampled at each timestamp provided in the timestamps list. For instance, the following stopping opportunities","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"s_1 = StoppingOpportunity([0.0], (t,state_list) -> state_list[1].coord[1] > 0) \ns_2 = StoppingOpportunity([1.0], (t,state_list) -> true)\ns_3 = StoppingOpportunity([4.0], (t,state_list) -> false)\ns_4 = StoppingOpportunity([1.0,8.0], (t,state_list) -> state_list[1].coord[1] > state_list[2].coord[1])","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"Which could be visually represented as ","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"(Image: StoppingOpportunity)","category":"page"},{"location":"dev/#Stopping-time.","page":"Dev","title":"Stopping time.","text":"","category":"section"},{"location":"dev/","page":"Dev","title":"Dev","text":"Next, we recall that a stopping time is simply a collection of stopping opportunities. The stopping opportunities are tested in chronological order and the first one to return true is used by the stopping time.","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"For instance, we could have","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"tau = StoppingTime([s_1,s_2])\nsigma = StoppingTime([s_3])\nrho = StoppingTime([s_4])","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"with the corresponding visualization","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"(Image: StoppingTime)","category":"page"},{"location":"dev/#Schedule","page":"Dev","title":"Schedule","text":"","category":"section"},{"location":"dev/","page":"Dev","title":"Dev","text":"Now that we have our stopping times, we could define the following simple schedule","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"schedule = Schedule(tau, [Schedule(sigma), Schedule(sigma, [Schedule(rho)])])","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"with the following visual representation","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"(Image: Deterministic Schedule)","category":"page"},{"location":"dev/#Sample","page":"Dev","title":"Sample","text":"","category":"section"},{"location":"dev/","page":"Dev","title":"Dev","text":"When it comes time to generate the sample,  whether or not the stopping time tau is triggered at s1 will have an impact on the timestamps each child process will have to sample. ","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"For instance, if tau is triggered at s1, we would have the following timelines.","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"(Image: Schedule)","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"In the above, two states will be have been sampled at s2. Whereas if tau is triggered at s_2, only one state will have been sampled at s1.","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"(Image: Schedule)","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"Because the number of timestamps might change from one iteration to the next, it makes it impractical to sample in place. However, many things don't change from one iteration to the next. The struct LoweredSchedule stores what is invariant across iterations.","category":"page"},{"location":"dev/#Road-Map","page":"Dev","title":"Road Map","text":"","category":"section"},{"location":"dev/","page":"Dev","title":"Dev","text":"(Image: Measuring Time)","category":"page"},{"location":"dev/","page":"Dev","title":"Dev","text":"Improve the clarity and ease of the user interface for creating stopping opportunities and schedule. Clean up the interface.\nImprove the sampler's speed by better implementing some of the helper methods, e.g. find.\nAdd the functionality of a fine-grained control over the random seeds.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [InvariantStopping]\nOrder   = [:type, :function,]","category":"page"},{"location":"reference/#InvariantStopping.BrownianMotion","page":"Reference","title":"InvariantStopping.BrownianMotion","text":"BrownianMotion\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.GeometricBrownianMotion","page":"Reference","title":"InvariantStopping.GeometricBrownianMotion","text":"GeometricBrownianMotion <: UnderlyingModel\n\nA geometric Brownian motion, specified by its rate, standard deviation sigma and dividend.\n\njulia> underlying_model = GeometricBrownianMotion(3.1,2.0,0.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.LoweredSample","page":"Reference","title":"InvariantStopping.LoweredSample","text":"LoweredSample\n\nA unit of sampling. \n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.LoweredSchedule","page":"Reference","title":"InvariantStopping.LoweredSchedule","text":"LoweredSchedule\n\nA schedule like object that services the need of the sampler. The timeline contains the sampling events (timestamps) from the earliest stopping opportunity of the parent schedule to the last stopping opportunity of the schedule.\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.Sample","page":"Reference","title":"InvariantStopping.Sample","text":"Sample\n\nA state sampled according to a given stopping time.  It is set to 'nothing' if the stopping time is never realized.\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.Schedule","page":"Reference","title":"InvariantStopping.Schedule","text":"Schedule\n\nSpecifies a directed tree over stopping times.\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.State","page":"Reference","title":"InvariantStopping.State","text":"State\n\nContains the coordinates of a given realization at a given time.\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.StoppingOpportunity","page":"Reference","title":"InvariantStopping.StoppingOpportunity","text":"StoppingOpportunity\n\nA Stopping Opportunity is a fundamental unit of stopping: it can only stop at one specific time. It consists of\n\nA list of timestamps. The last timestamp in this list specifies when the predicate is evaluated to decide on stopping.\nA function that determines whether stopping should occur based on the current time and the states associated with each timestamp in timestamp_list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.StoppingTime","page":"Reference","title":"InvariantStopping.StoppingTime","text":"StoppingTime\n\nA stopping time stops at the first  stopping opportunity for which its predicate returns true.\n\nIt consists simply of a list of stopping opportunities.\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.UnderlyingModel","page":"Reference","title":"InvariantStopping.UnderlyingModel","text":"UnderlyingModel\n\nAbstract class for processes that implement the forward method.\n\n\n\n\n\n","category":"type"},{"location":"reference/#InvariantStopping.DeterministicTime-Tuple{Any}","page":"Reference","title":"InvariantStopping.DeterministicTime","text":"DeterministicTime\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.HittingTime-Tuple{Any, Any}","page":"Reference","title":"InvariantStopping.HittingTime","text":"HittingTime\n\nEvalues the provided predicate at each timestamp in timestamp_list.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.Star-Tuple{Any, Integer}","page":"Reference","title":"InvariantStopping.Star","text":"Star(::Any,::Integer)\n\nConstructs a tree where the branching factor is applied to the first timestamp only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.Tree-Tuple{Any, Integer}","page":"Reference","title":"InvariantStopping.Tree","text":"Tree\n\nConstructs a tree of schedule with provided branching factor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.forward-Tuple{Any, Any, Any, UnderlyingModel}","page":"Reference","title":"InvariantStopping.forward","text":"forward\n\nSimulate the process from the given state from now to a later time. Returns the state generated at the later time. Subtype of UnderlyingModel are informally required to implement the forward method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.get_all_leaf-Tuple{Any}","page":"Reference","title":"InvariantStopping.get_all_leaf","text":"get_all_leaf\n\nReturns a list of all leafs from the provided sample onward.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.get_all_timestamp-Tuple{StoppingOpportunity}","page":"Reference","title":"InvariantStopping.get_all_timestamp","text":"get_all_timestamp\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.get_all_trajectory-Tuple{Any}","page":"Reference","title":"InvariantStopping.get_all_trajectory","text":"get_all_trajectory\n\nReturns a list of all trajectories from the provided sampled onward. A trajectory is a list of states from the provided sample onward to a leaf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.get_history-Tuple{S} where S","page":"Reference","title":"InvariantStopping.get_history","text":"get_history\n\nReturns the list of samples starting from the root to the provided sample.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.get_sample-Union{Tuple{T}, Tuple{State, Schedule{T}, UnderlyingModel}} where T","page":"Reference","title":"InvariantStopping.get_sample","text":"get_sample\n\nPopulates the provided schedule by simulating the underlying process from the provided state onward.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.lower-Union{Tuple{Schedule{T}}, Tuple{T}} where T","page":"Reference","title":"InvariantStopping.lower","text":"lower\n\nRecursively build a lowered schedule from the provided schedule.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.plot-Tuple{Union{LoweredSample, Sample}}","page":"Reference","title":"InvariantStopping.plot","text":"plot(::Union{Sample,LoweredSample})\n\n1D : Plot a sample with the x-axis representing time and the y-axis representing the first coordinate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#InvariantStopping.plot_lower-Tuple{Any}","page":"Reference","title":"InvariantStopping.plot_lower","text":"plot_lower\n\n\n\n\n\n","category":"method"},{"location":"#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Explore how optimal stopping problems transform under random-time coordinate transforms.","category":"page"},{"location":"#Installation","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"InvariantStopping can be installed by running","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"using Pkg; \nPkg.add(\"InvariantStopping\")","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"You can validate the success of the installation by running the following toy example.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"using InvariantStopping\n\nusing Gadfly # hide\nset_default_plot_size(6inch, 4inch) # hide\nstate = State(0.0) # x coord\nschedule = InvariantStopping.Tree(LinRange(0,10,4), 3)\nprocess = BrownianMotion()\nsample = get_sample(state, schedule, process)\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"The generated Sample is a tree of trajectories made by a standard 1-dimensional BrownianMotion with State initialized at the origin.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"p = InvariantStopping.plot(sample) # Plot 1D\ndraw(SVG(\"ternary_tree_1D.svg\"), p); # hide\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"#Overview","page":"Usage","title":"Overview","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"The target of this package is to allow the user to sample a process along arbitrary stopping times. ","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Perhaps the best way to understand the idea is with an example. ","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"state = State(0.0) \nprocess = BrownianMotion()\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Instead of having a tree over DeterministicTime ","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: Ternary Tree)","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Let us define a tree over StoppingTime.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: Ternary Tree)","category":"page"},{"location":"#Stopping-Times","page":"Usage","title":"Stopping Times","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"To build our stopping times, we first need a few predicates.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"function up_deviation(t,state_list)\n  x = state_list[1].coord[1]  \n  return (x > 0.3) || t >= 10.0\nend\n\nfunction down_deviation(t,state_list)\n  x = state_list[1].coord[1]\n  return (x < -0.3) || t >= 10.0\nend\n\nfunction large_deviation(t,state_list)\n  x = state_list[1].coord[1]\n  return (abs(x) > 0.4) || t >= 10.0\nend\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Then we create three hitting time using the HittingTime constructor.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"timelist = LinRange(0,10,100)\n\nup_deviation_hit= HittingTime(timelist, up_deviation)\ndown_deviation_hit = HittingTime(timelist, down_deviation)\nlarge_deviation_hit = HittingTime(timelist, large_deviation)\nnothing #hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Having three stopping times, we will use them to populate our schedule.","category":"page"},{"location":"#Schedule","page":"Usage","title":"Schedule","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"We induce an ordering on our stopping times via a directed graph made of Schedule nodes.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"deviation_escalation = Schedule(up_deviation_hit, [Schedule(down_deviation_hit, [Schedule(large_deviation_hit) for _ in 1:5 ]) for _ in 1:5])\n\nschedule = Schedule(DeterministicTime(0.0), [deviation_escalation for _ in 1:12])\nnothing #hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"The above schedule defines a tree where each layer is populated by a single type of stopping time. Let's see what our original 1-dimensional Brownian motion looks like when sampled according to our newly defined schedule.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"sample = get_sample(state, schedule, process)\np = InvariantStopping.plot(sample) # Plot 1D\ndraw(SVG(\"deviation_explosion.svg\"), p); # hide\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"We can observe that some paths were stopped before reaching the end. We can also observe that our choice of schedule causes the zig-zagging trajectories to be over-represented.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Note that this shows only the actual Sample, as opposed to all the intermediate LoweredSample that were sampled in order to service the stopping times. If we want to include all the intermediate steps in our plot, we can do.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"p = InvariantStopping.plot_lower(sample) # Plot 1D\ndraw(SVG(\"lowered_deviation_explosion.svg\"), p); # hide\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"#State","page":"Usage","title":"State","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"We could have chosen to simulate our Brownian motion in four dimensions as opposed to two. ","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"state = State((0.0,0.0,0.0,0.0))\nnothing #hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Let's choose our schedule such that the process duplicates when it hits the boundary of the 4D unit sphere.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"function sphere(t,state_list)\n  return sqrt(sum([state_list[1].coord[i]^2 for i in 1:length(state_list)])) > 1 || t >= 10.0\nend\n\nfunction stop_at_ten(t,state_list)\n  return  t >= 10.0\nend\n\nhit_ten = HittingTime(LinRange(0,10,100),stop_at_ten)\nhit_sphere = HittingTime(LinRange(0,10,100), sphere)\nhit_sphere_doubling = Schedule(hit_sphere, [Schedule(hit_ten) for _ in 1:2])\n\nschedule = Schedule(DeterministicTime(0.0),[hit_sphere_doubling for _ in 1:20 ])\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"We sample.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"sample = get_sample(state,schedule,process)\nnothing #hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Let's plot the 4-dimensional brownian motion along its first two coordinates.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"p = InvariantStopping.plot(sample,[1,2]) \ndraw(SVG(\"brownian_motion_4d.svg\"), p); # hide\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"And ","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"p = InvariantStopping.plot_lower(sample,[1,2]) \ndraw(SVG(\"lowered_brownian_motion_4d.svg\"), p); # hide\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"#Process","page":"Usage","title":"Process","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"So far we have used the process BrownianMotion but we could a different process, for instance GeometricBrownianMotion.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"state = State(1.0)\nprocess = GeometricBrownianMotion(0.06, 0.2, 0.0) # (rate, sigma, dividend)\nnothing #hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Let's see what happens if we make the process doubles once it crosses a certain threshold.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"function space_time_deviation(t,state_list)\n  x = state_list[1].coord[1]  \n  return x > 4 - t/10  || t >= 10.0\nend\n\nfunction stop_at_ten(t,state_list)\n  return  t >= 10.0\nend\n\nhit_ten = HittingTime(LinRange(0,10,100),stop_at_ten)\nspace_time_deviation_doubling = Schedule(HittingTime(timelist, space_time_deviation),[Schedule(hit_ten) for _ in 1:2])\n\nschedule = Schedule(DeterministicTime(0.0),[space_time_deviation_doubling for _ in 1:15])\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"sample = get_sample(state, schedule, process)\np = InvariantStopping.plot(sample) \ndraw(SVG(\"geometric_brownian_motion_1d.svg\"), p); # hide\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"p = InvariantStopping.plot_lower(sample) \ndraw(SVG(\"lower_geometric_brownian_motion_1d.svg\"), p); # hide\nnothing # hide","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"One can define a new process by implementing the forward method for a concrete type. See  UnderlyingModel.","category":"page"},{"location":"#Summary","page":"Usage","title":"Summary","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"We have seen how the InvariantStopping package can be used to generate sample ","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"sample = get_sample(state, schedule, process)","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"where the state, schedule and process can be varied independently. Moreoever, the package allows one to define very generic schedule in the form of a directed tree over the space of stopping times. ","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"(Image: Ternary Tree)","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"For more information on schedule, check dev.","category":"page"},{"location":"docstring_guidelines/#Julia-Docstring-Best-Practices","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"When documenting functions, types, and other objects in our package, follow these best practices:","category":"page"},{"location":"docstring_guidelines/#1.-**Placement**","page":"Julia Docstring Best Practices","title":"1. Placement","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"Place the docstring immediately before the object it documents, such as a function, type, or macro.","category":"page"},{"location":"docstring_guidelines/#2.-**Usage-Statement**","page":"Julia Docstring Best Practices","title":"2. Usage Statement","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"Start with a brief usage statement showing the function signature.\nThe usage statement should be indented and set apart from the main description.","category":"page"},{"location":"docstring_guidelines/#3.-**Description**","page":"Julia Docstring Best Practices","title":"3. Description","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"Provide a detailed description of the function or type, elaborating on its purpose, behavior, and any relevant context.","category":"page"},{"location":"docstring_guidelines/#4.-**Arguments-and-Returns**","page":"Julia Docstring Best Practices","title":"4. Arguments & Returns","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"Organize details under # Arguments and # Returns sections.\nFor each argument, start with its name, followed by a colon, and then its description.\nDescribe the return value in a similar manner.","category":"page"},{"location":"docstring_guidelines/#5.-**Examples**","page":"Julia Docstring Best Practices","title":"5. Examples","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"Offer practical examples to illustrate and clarify usage.\nEnclose examples within a Julia code block.","category":"page"},{"location":"docstring_guidelines/#6.-**Additional-Sections**","page":"Julia Docstring Best Practices","title":"6. Additional Sections","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"For objects of greater complexity, consider adding sections like # Notes, # References, or # See Also.","category":"page"},{"location":"docstring_guidelines/#7.-**Markdown-Support**","page":"Julia Docstring Best Practices","title":"7. Markdown Support","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Julia Docstring Best Practices","title":"Julia Docstring Best Practices","text":"Use Markdown formatting for clarity and emphasis. This includes bold, italic, and links.","category":"page"}]
}
