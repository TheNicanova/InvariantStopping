var documenterSearchIndex = {"docs":
[{"location":"home/#InvariantStopping","page":"Home","title":"InvariantStopping","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"A parametrized Monte Carlo solver for the optimal stopping problem.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"A package for simulating trajectories, running optimal stopping algorithms, plotting results, as well as exploring how optimal stopping problems transform under random-time coordinate transforms.","category":"page"},{"location":"home/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"InvariantStopping can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"pkg> add InvariantStopping","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"or with using Pkg; Pkg.add(\"InvariantStopping\").","category":"page"},{"location":"home/#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"First, we load InvariantStopping (if we haven't already done so):","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"julia> using InvariantStopping","category":"page"},{"location":"home/#Sampling","page":"Home","title":"Sampling","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"In order to generate samples, we must first specify an initial state, a schedule and an underlying model.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"julia> initial_state = State(0.0,1.0) # (time,coord)\n\njulia> schedule = Schedule(LinRange(0.0, 10, 20)) \n\njulia> underlying_model = GeometricBrownianMotion(3,4,5); #rate, sigma, dividend","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"The underlying_model, starting from the initialgit ","category":"page"},{"location":"home/#Pricing","page":"Home","title":"Pricing","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"To price (or solve) the optimal stopping problem, one needs a Sample object as well as a PricingModel.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"julia> pricing_model = Longstaff() # Returns a pricing model (Longstaff approach) set with default settings\n\njulia> result = price(sample, pricing_model)","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Again, one can plot the results. For instance, one has:","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"julia> plot(result)","category":"page"},{"location":"method/#Constructors","page":"Method","title":"Constructors","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"Schedule(::LinRange{<:Number,<:Integer})","category":"page"},{"location":"method/#InvariantStopping.Schedule-Tuple{LinRange{<:Number}}","page":"Method","title":"InvariantStopping.Schedule","text":"Schedule(::LinRange)\n\nConstructor for Schedule. Creates a schedule representing a trajectory that stops at times given by the argument.\n\nExamples\n\njulia> schedule = Schedule(LinRange(0,10,11))\n\n\n\n\n\n\n","category":"method"},{"location":"method/","page":"Method","title":"Method","text":"Schedule(::LinRange{<:Number,<:Integer}, ::Integer)","category":"page"},{"location":"method/#InvariantStopping.Schedule-Tuple{LinRange{<:Number}, Integer}","page":"Method","title":"InvariantStopping.Schedule","text":"Schedule(::LinRange, ::Integer)\n\nConstructor for Schedule. Creates a schedule representing a tree of trajectories with a prescribed branching factor. Examples:\n\njulia> schedule = Schedule(LinRange(0,10,11),2)\n\n\n\n\n\n\n","category":"method"},{"location":"method/","page":"Method","title":"Method","text":"Sample(::State, ::Schedule, ::UnderlyingModel)","category":"page"},{"location":"method/#InvariantStopping.Sample-Tuple{State, Schedule, UnderlyingModel}","page":"Method","title":"InvariantStopping.Sample","text":"Sample(::State, ::Schedule, ::UnderlyingModel)\n\nConstructor for Sample. Starting from the initial State, it samples from the UnderlyingModel according to the Schedule.\n\nExamples\n\njulia> initial_state = State(0.0, 4.5)\n\njulia> schedule = Schedule(LinRange(0,10,5))\n\njulia> underlying_model = GeometricBrownianMotion() # Default parameters\n\njulia> sample = Sample(initial_state, schedule, underlying_model)\n\n\n\n\n\n","category":"method"},{"location":"method/#State-Transition","page":"Method","title":"State Transition","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"forward_to","category":"page"},{"location":"method/#InvariantStopping.forward_to","page":"Method","title":"InvariantStopping.forward_to","text":"forward_to(::State, ::Number, ::UnderlyingModel)\n\nForwards a (State)(@ref) in time using the provided ()UnderlyingModel](@ref). Returns a (State)(@ref).\n\nExamples\n\njulia> initial_state = State(0.0,1.0)\n\njulia> forward_time = 10.0\n\njulia> underlying_model = GeometricBrownianMotion()\n\njulia> forward_state = forward_to(initial_state, forward_time, underlying_model)\n\n\n\n\n\n\n","category":"function"},{"location":"method/#Plotting","page":"Method","title":"Plotting","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"plot","category":"page"},{"location":"method/#InvariantStopping.plot","page":"Method","title":"InvariantStopping.plot","text":"plot(::Sample)\n\nPlot a sample with the x-axis representing time and the y-axis representing the first coordinate.\n\nExamples:\n\n\nstate = State(0.0,(1.0,))\nbinary_tree = Schedule(LinRange(0,10,11),2)\nunderlying_model = GeometricBrownianMotion(0.01,0.05,0.0)\n\nsample = Sample(state, tree, underlying_model)\n\nplot(sample)\n\n(Image: Sample plot)\n\n\nstate = State(0.0,(1.0,))\nstar = Star(LinRange(0,10,11),12)\nunderlying_model = GeometricBrownianMotion(0.01,0.05,0.0)\n\nsample = Sample(state, star, underlying_model)\n\nplot(sample)\n\n(Image: Sample plot)\n\n\n\n\n\nplot(::Sample, ::Integer)\n\nA helper function for recursively plotting trajectories.\n\n\n\n\n\n","category":"function"},{"location":"plot/#Plotting-Sample","page":"Plotting","title":"Plotting Sample","text":"","category":"section"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"plot(::Sample)","category":"page"},{"location":"plot/#InvariantStopping.plot-Tuple{Sample}","page":"Plotting","title":"InvariantStopping.plot","text":"plot(::Sample)\n\nPlot a sample with the x-axis representing time and the y-axis representing the first coordinate.\n\nExamples:\n\n\nstate = State(0.0,(1.0,))\nbinary_tree = Schedule(LinRange(0,10,11),2)\nunderlying_model = GeometricBrownianMotion(0.01,0.05,0.0)\n\nsample = Sample(state, tree, underlying_model)\n\nplot(sample)\n\n(Image: Sample plot)\n\n\nstate = State(0.0,(1.0,))\nstar = Star(LinRange(0,10,11),12)\nunderlying_model = GeometricBrownianMotion(0.01,0.05,0.0)\n\nsample = Sample(state, star, underlying_model)\n\nplot(sample)\n\n(Image: Sample plot)\n\n\n\n\n\n","category":"method"},{"location":"type/#Overview","page":"Type","title":"Overview","text":"","category":"section"},{"location":"type/#State-Space","page":"Type","title":"State Space","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"State","category":"page"},{"location":"type/#InvariantStopping.State","page":"Type","title":"InvariantStopping.State","text":"State\n\nFields\n\ntime: Represents concrete time.\n\ncoord: An N dimensional coordinate.\n\ncomment: Comment\nA state is an immutable object, perhaps it should be made mutable.\n\ncomment: Comment\nWe still debate as whether or not to include the time component inside the state object.\n\nExamples\n\njulia> state = State(0.0, (1.0,0.0))\n\njulia> state = State(0.0, (1.0,))\n\njulia> state = State(0.5, 1.0)\n\njulia> time = get_time(state)\n\njulia> coord = get_coord(state)\n\n\n\n\n\n","category":"type"},{"location":"type/#Stopping-Times","page":"Type","title":"Stopping Times","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"StoppingPolicy","category":"page"},{"location":"type/#InvariantStopping.StoppingPolicy","page":"Type","title":"InvariantStopping.StoppingPolicy","text":"StoppingPolicy\n\nAbstract type that specifies when to stop.\n\nIt is either DeterministicStopping or StoppingTime.\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"DeterministicStopping","category":"page"},{"location":"type/#InvariantStopping.DeterministicStopping","page":"Type","title":"InvariantStopping.DeterministicStopping","text":"DeterministicStopping <: StoppingPolicy\n\nThis type represents stopping at a specific concrete time as opposed to following a generic stopping time.\n\nExamples\n\njulia> simple_stopping_rule = DeterministicStopping(5.0)\n\njulia> time = get_time(simple_stopping_rule) # 5.0\n\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"StoppingTime","category":"page"},{"location":"type/#InvariantStopping.StoppingTime","page":"Type","title":"InvariantStopping.StoppingTime","text":"StoppingTime <: StoppingPolicy\n\nThis abstract type represents a generic stopping time.\n\n\n\n\n\n","category":"type"},{"location":"type/#Ordering-Stopping-Times","page":"Type","title":"Ordering Stopping Times","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"Schedule","category":"page"},{"location":"type/#InvariantStopping.Schedule","page":"Type","title":"InvariantStopping.Schedule","text":"Schedule\n\nAn abstract type representing partial orders over StoppingPolicy.\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"NodeSchedule","category":"page"},{"location":"type/#InvariantStopping.NodeSchedule","page":"Type","title":"InvariantStopping.NodeSchedule","text":"NodeSchedule <: Schedule\n\nThis type stores a StoppingPolicy and a collection of Schedule.  Each of the later is to be interpreted as StoppingPolicy to happen at a later point in time.\n\nExamples\n\njulia> stopping_policy_1 = DeterministicStopping(3.0)\n\njulia> stopping_policy_2 = DeterministicStopping(4.0)\n\njulia> leaf = LeafSchedule(stopping_policy_2)\n\njulia> node = NodeSchedule(stopping_policy_1, (leaf,leaf))\n\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"LeafSchedule","category":"page"},{"location":"type/#InvariantStopping.LeafSchedule","page":"Type","title":"InvariantStopping.LeafSchedule","text":"LeafSchedule <: Schedule\n\nThis type stores a StoppingPolicy. To be interpreted as the last StoppingPolicy to be followed.\n\n\n\n\n\n","category":"type"},{"location":"type/#Forwarding-States","page":"Type","title":"Forwarding States","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"UnderlyingModel","category":"page"},{"location":"type/#InvariantStopping.UnderlyingModel","page":"Type","title":"InvariantStopping.UnderlyingModel","text":"UnderlyingModel\n\nAn abstract type representing the transition function of a markov process.\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"GeometricBrownianMotion","category":"page"},{"location":"type/#InvariantStopping.GeometricBrownianMotion","page":"Type","title":"InvariantStopping.GeometricBrownianMotion","text":"GeometricBrownianMotion <: UnderlyingModel\n\nA geometric Brownian motion, specified by its rate, standard deviation sigma and dividend.\n\njulia> underlying_model = GeometricBrownianMotion(3.1,2.0,0.0)\n\n\n\n\n\n","category":"type"},{"location":"type/#Sampling","page":"Type","title":"Sampling","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"Sample","category":"page"},{"location":"type/#InvariantStopping.Sample","page":"Type","title":"InvariantStopping.Sample","text":"Sample\n\nAbstract type representing a realization.\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"NodeSample","category":"page"},{"location":"type/#InvariantStopping.NodeSample","page":"Type","title":"InvariantStopping.NodeSample","text":"NodeSample <: Sample\n\nThis type stores a State, a Schedule, an UnderlyingModel and a collection of Sample.  Each of the later is to be interpreted as happening at a later point in time.\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"LeafSample","category":"page"},{"location":"type/#InvariantStopping.LeafSample","page":"Type","title":"InvariantStopping.LeafSample","text":"Leaf <: Sample\n\nThis type stores a State, a Schedule, an UnderlyingModel. To be interpreted as the last piece of sample data along a schedule branch.\n\n\n\n\n\n","category":"type"},{"location":"docstring_guidelines/#Julia-Docstring-Best-Practices","page":"Appendix: Docstring Guidelines","title":"Julia Docstring Best Practices","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"When documenting functions, types, and other objects in our package, follow these best practices:","category":"page"},{"location":"docstring_guidelines/#.-**Placement**","page":"Appendix: Docstring Guidelines","title":"1. Placement","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"Place the docstring immediately before the object it documents, such as a function, type, or macro.","category":"page"},{"location":"docstring_guidelines/#.-**Usage-Statement**","page":"Appendix: Docstring Guidelines","title":"2. Usage Statement","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"Start with a brief usage statement showing the function signature.\nThe usage statement should be indented and set apart from the main description.","category":"page"},{"location":"docstring_guidelines/#.-**Description**","page":"Appendix: Docstring Guidelines","title":"3. Description","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"Provide a detailed description of the function or type, elaborating on its purpose, behavior, and any relevant context.","category":"page"},{"location":"docstring_guidelines/#.-**Arguments-and-Returns**","page":"Appendix: Docstring Guidelines","title":"4. Arguments & Returns","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"Organize details under # Arguments and # Returns sections.\nFor each argument, start with its name, followed by a colon, and then its description.\nDescribe the return value in a similar manner.","category":"page"},{"location":"docstring_guidelines/#.-**Examples**","page":"Appendix: Docstring Guidelines","title":"5. Examples","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"Offer practical examples to illustrate and clarify usage.\nEnclose examples within a Julia code block.","category":"page"},{"location":"docstring_guidelines/#.-**Additional-Sections**","page":"Appendix: Docstring Guidelines","title":"6. Additional Sections","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"For objects of greater complexity, consider adding sections like # Notes, # References, or # See Also.","category":"page"},{"location":"docstring_guidelines/#.-**Markdown-Support**","page":"Appendix: Docstring Guidelines","title":"7. Markdown Support","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"Use Markdown formatting for clarity and emphasis. This includes bold, italic, and links.","category":"page"},{"location":"docstring_guidelines/#Example:","page":"Appendix: Docstring Guidelines","title":"Example:","text":"","category":"section"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"The following ","category":"page"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"\"\"\"\n    calculate(x, y; z=1.0)\n\nCalculate the result based on inputs `x`, `y`, and an optional parameter `z`.\n\n# Arguments\n- `x`: The first input (should be a positive integer).\n- `y`: The second input (should be a non-zero integer).\n- `z`: An optional parameter with a default value of 1.0.\n\n# Returns\n- A floating-point number representing the result.\n\n# Examples\n    calculate(5, 3)\n    calculate(5, 3, z=2.5)\n\"\"\"","category":"page"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"willproduce the following entry.","category":"page"},{"location":"docstring_guidelines/","page":"Appendix: Docstring Guidelines","title":"Appendix: Docstring Guidelines","text":"calculate(x, y; z=1.0)","category":"page"}]
}
